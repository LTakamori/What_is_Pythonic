# <center> Python函数</center>

## 对象引用的的理解 & 垃圾回收机制

1. Python中的变量不应该看做一个对象本身，而是应该看作一个对于对象本身的引用（变量是一张贴纸，而不是盒子）。
2. 给一个变量赋值时，对象在赋值之前就已经被创建了，赋值语句为一个已存在的对象添加一个引用（将一张贴纸贴到一个盒子上），在某些情况下，对象在赋值语句右侧仙贝创建，然后再将语句左侧的引用绑定到对象上。
3. ==运算符已规定的方式比较引用绑定的两个对象的值（对象中保存的数据），而is则比较对象的id（是否为同一个对象），==  调用对象的 .\_\_eq__() 方法，继承自objectde的\_\_eq()\_\_方法在重载前比较的也是对象的id。
4. 由于tuple中保存的也是这种引用，所以tuple中的不变性指的是引用本身不变，而不是引用指向的对象 不变，比如tuple中的list还是可以调用append等方法来改变自身
5. 当一个对象不存在引用指向他时，他就会被垃圾回收，可以通过del()来删除引用
6. 弱引用不会增加对象的引用数量，存在弱引用不妨碍对象被垃圾回收

## Python中的函数是一等对象

一等对象指：

 	1. 能在运行时被动态创建
 	2. 能赋值给数据结构&变量
 	3. 能作为参数进行传递&返回

## 函数装饰器

1. 函数装饰器是一个可调用对象，通常将一个函数作为入参，并返回一个函数，在加载模块时立即就进行执行
2. 装饰符@是一个语法糖， 进行的就是 1）中的操作
3. 装饰器可以将为函数加上部分功能，比如@clock等
4. 装饰器也可以用来将函数加入注册表中，比如flask中得到@route

## 闭包

1. 嵌套函数里的内层函数可以获取外层函数的变量
2. 如果外层函数返回内层的嵌套函数，在单独调用返回的内衬函数时，仍能获取外层函数中的变量
3. 通过1. 2. 将一部分自由变量（free variable）绑定在一个函数上的方式就是闭包（closure）
4. 综上，闭包是一种函数，它保留了定义函数时存在的自由变量的绑定，这样调用函数时虽然定义域不可用，但绑定仍可用
5. 如果尝试将闭包的不可变变量进行改变，会将自由变量转化为函数的本地变量，可以通过 nonlocal声明来指定，这样就算内层函数尝试改变不可变的自由变量时，不会将自由变量转化为局部变量。
6. 当需要实现一个需要"记忆"environment或者数据的method时，closure由于自身绑定的自由变量，可以用来替代类更加简介地实现这一需求